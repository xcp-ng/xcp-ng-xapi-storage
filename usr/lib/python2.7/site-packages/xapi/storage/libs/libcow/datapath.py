from __future__ import absolute_import
import urlparse
import sys

from xapi.storage.libs import tapdisk, image, qemudisk, util
from xapi.storage import log

from .callbacks import VolumeContext
from .imageformat import ImageFormat
from .metabase import VolumeMetabase
from .intellicache import IntelliCache
from .lock import Lock

vdi_enable_intellicache = False


class COWDatapath(object):

    @staticmethod
    def parse_uri(uri):
        raise NotImplementedError('Override in dp specifc class')

    @staticmethod
    def attach_internal(dbg, opq, vdi, vol_path, cb):
        raise NotImplementedError('Override in dp specifc class')

    @classmethod
    def attach(cls, dbg, uri, domain, cb):
        sr, key = cls.parse_uri(uri)
        with VolumeContext(cb, sr, 'r') as opq:

            meta_path = cb.volumeMetadataGetPath(opq)
            db = VolumeMetabase(meta_path)
            vdi = db.get_vdi_by_id(key)
            # activate LVs chain here
            db.close()

            vol_path = cb.volumeGetPath(opq, str(vdi.volume.id))

            protocol, params = cls.attach_internal(
                dbg, opq, vdi, vol_path, cb)

        return {
            'domain_uuid': '0',
            'implementation': [protocol, params],
        }

    @staticmethod
    def activate_internal(dbg, opq, vdi, img, cb):
        raise NotImplementedError('Override in dp specifc class')

    @classmethod
    def activate(cls, dbg, uri, domain, cb):
        this_host_label = cb.get_current_host()
        sr, key = cls.parse_uri(uri)
        with VolumeContext(cb, sr, 'w') as opq:
            meta_path = cb.volumeMetadataGetPath(opq)
            db = VolumeMetabase(meta_path)

            with Lock(opq, 'gl', cb):
                with db.write_context():
                    vdi = db.get_vdi_by_id(key)
                    # Raise Storage Error VDIInUse - 24
                    if vdi.active_on:
                        raise util.create_storage_error(
                            "SR_BACKEND_FAILURE_24",
                            ["VDIInUse", "The VDI is currently in use"])
                    vol_path = cb.volumeGetPath(opq, str(vdi.volume.id))
                    if vdi.sharable:
                        img = image.Raw(vol_path)
                    else:
                        db.update_vdi_active_on(vdi.uuid, this_host_label)
                        img = image.Cow(vol_path)

                    cls.activate_internal(dbg, opq, vdi, img, cb)

            db.close()

    @staticmethod
    def deactivate_internal(dbg, opq, vdi, img, cb):
        raise NotImplementedError('Override in dp specifc class')

    @classmethod
    def deactivate(cls, dbg, uri, domain, cb):
        sr, key = cls.parse_uri(uri)
        with VolumeContext(cb, sr, 'w') as opq:
            meta_path = cb.volumeMetadataGetPath(opq)
            db = VolumeMetabase(meta_path)

            with Lock(opq, 'gl', cb):
                with db.write_context():
                    vdi = db.get_vdi_by_id(key)
                    vol_path = cb.volumeGetPath(opq, str(vdi.volume.id))
                    if vdi.sharable:
                        img = image.Raw(vol_path)
                    else:
                        db.update_vdi_active_on(vdi.uuid, None)
                        img = image.Cow(vol_path)

                    cls.deactivate_internal(dbg, opq, vdi, img, cb)

            db.close()

    @staticmethod
    def detach_internal(dbg, opq, vdi, cb):
        raise NotImplementedError('Override in dp specifc class')

    @classmethod
    def detach(cls, dbg, uri, domain, cb):
        sr, key = cls.parse_uri(uri)
        with VolumeContext(cb, sr, 'r') as opq:
            meta_path = cb.volumeMetadataGetPath(opq)
            db = VolumeMetabase(meta_path)
            vdi = db.get_vdi_by_id(key)
            # deactivate LVs chain here
            db.close()

            cls.detach_internal(dbg, opq, vdi, cb)

    @classmethod
    def create_single_clone(cls, db, sr, key, cb):
        pass

    @classmethod
    def epc_open(cls, dbg, uri, persistent, cb):
        log.debug("{}: Datapath.epc_open: uri == {}".format(dbg, uri))
        sr, key = cls.parse_uri(uri)
        with VolumeContext(cb, sr, 'w') as opq:
            meta_path = cb.volumeMetadataGetPath(opq)
            db = VolumeMetabase(meta_path)

            try:
                with Lock(opq, 'gl', cb):
                    try:
                        with db.write_context():
                            vdi = db.get_vdi_by_id(key)
                            vol_path = cb.volumeGetPath(
                                opq, str(vdi.volume.id))
                            image_utils = ImageFormat.get_format(
                                vdi.image_type).image_utils
                            if (persistent):
                                log.debug(
                                    ("{}: Datapath.epc_open: "
                                     "{} is persistent").format(dbg, vol_path)
                                )
                                if vdi.nonpersistent:
                                    # Truncate, etc
                                    image_utils.reset(dbg, vol_path)
                                    db.update_vdi_nonpersistent(vdi.uuid, 1)
                            elif vdi.nonpersistent:
                                log.debug(
                                    ("{}: Datapath.epc_open: {} already "
                                     "marked non-persistent").format(dbg,
                                                                     vol_path)
                                )
                                # truncate
                                image_utils.reset(dbg, vol_path)
                            else:
                                log.debug(
                                    ("{}: Datapath.epc_open: {} is "
                                     "non-persistent").format(dbg, vol_path)
                                )
                                db.update_vdi_nonpersistent(vdi.uuid, 1)
                                if not image_utils.is_empty(dbg, vol_path):
                                    # Create single clone
                                    COWDatapath.create_single_clone(
                                        db, sr, key, cb)
                    except:
                        log.error(
                            ("{}: Datapath.epc_open: failed to complete "
                             "open, {}").format(dbg, sys.exc_info()[0])
                        )
                        raise
            finally:
                db.close()

        return None

    @classmethod
    def epc_close(cls, dbg, uri, cb):
        log.debug("{}: Datapath.epc_close: uri == {}".format(dbg, uri))
        sr, key = cls.parse_uri(uri)
        with VolumeContext(cb, sr, 'w') as opq:
            meta_path = cb.volumeMetadataGetPath(opq)
            db = VolumeMetabase(meta_path)

            try:
                with Lock(opq, 'gl', cb):
                    with db.write_context():
                        vdi = db.get_vdi_by_id(key)
                        vol_path = cb.volumeGetPath(opq, str(vdi.volume.id))
                        image_utils = ImageFormat.get_format(
                            vdi.image_type).image_utils
                        if vdi.nonpersistent:
                            # truncate
                            image_utils.reset(dbg, vol_path)
                            db.update_vdi_nonpersistent(vdi.uuid, None)
            except:
                log.error(
                    ("{}: Datapath.epc_close: failed to complete "
                     "close, {}").format(dbg, sys.exc_info()[1])
                )
                raise
            finally:
                db.close()

        return None


class TapdiskDatapath(COWDatapath):
    """
    Datapath handler for tapdisk
    """

    @staticmethod
    def parse_uri(uri):
        # uri will be like:
        # "vhd+tapdisk://<sr-type>/<sr-mount-or-volume-group>|<volume-name>"
        mount_or_vg, name = urlparse.urlparse(uri).path.split('|')
        return ('vhd:///' + mount_or_vg, name)

    @staticmethod
    def attach_internal(dbg, opq, vdi, vol_path, cb):
        protocol = 'Tapdisk3'
        if ((vdi.volume.parent_id is not None and
             vdi_enable_intellicache)):
            parent_cow_path = cb.volumeGetPath(
                opq, str(vdi.volume.parent_id))
            IntelliCache.attach(
                dbg,
                vol_path,
                parent_cow_path
            )
        else:
            tap = tapdisk.create(dbg)
            tapdisk.save_tapdisk_metadata(
                dbg, cb.get_data_metadata_path(opq, vdi.uuid), tap)
            params = tap.block_device()
        # TODO extra_params = {}

        return (protocol, params)

    @staticmethod
    def activate_internal(dbg, opq, vdi, img, cb):
        if ((vdi.volume.parent_id is not None and
             vdi_enable_intellicache)):
            parent_cow_path = cb.volumeGetPath(
                opq,
                str(vdi.volume.parent_id)
            )

            IntelliCache.activate(
                img.path,
                parent_cow_path,
                vdi.nonpersistent
            )
        else:
            vdi_meta_path = cb.get_data_metadata_path(opq, vdi.uuid)
            tap = tapdisk.load_tapdisk_metadata(
                dbg, vdi_meta_path)
            # enable read caching by default since this is
            # goint to be used from licensed SRs
            tap.open(dbg, img, False)
            tapdisk.save_tapdisk_metadata(
                dbg, vdi_meta_path, tap)

    @staticmethod
    def deactivate_internal(dbg, opq, vdi, img, cb):
        """
        Do the tapdisk specific deactivate
        """
        if ((vdi.volume.parent_id is not None and
             vdi_enable_intellicache)):
            parent_cow_path = cb.volumeGetPath(
                opq, str(vdi.volume.parent_id))
            IntelliCache.deactivate(
                dbg, img.path, parent_cow_path)
        else:
            tap = tapdisk.load_tapdisk_metadata(
                dbg, cb.get_data_metadata_path(opq, vdi.uuid))
            tap.close(dbg)

    @staticmethod
    def detach_internal(dbg, opq, vdi, cb):
        if ((vdi.volume.parent_id is not None and
             vdi_enable_intellicache)):
            parent_cow_path = cb.volumeGetPath(
                opq, str(vdi.volume.parent_id))
            vol_path = cb.volumeGetPath(opq, str(vdi.volume.id))
            IntelliCache.detach(dbg, vol_path, parent_cow_path)
        else:
            vdi_meta_path = cb.get_data_metadata_path(opq, vdi.uuid)
            tap = tapdisk.load_tapdisk_metadata(dbg, vdi_meta_path)
            tap.destroy(dbg)
            tapdisk.forget_tapdisk_metadata(dbg, vdi_meta_path)


class QdiskDatapath(COWDatapath):
    """
    Datapath handler for qdisk
    """

    @staticmethod
    def parse_uri(uri):
        # uri will be like:
        # "vhd+tapdisk://<sr-type>/<sr-mount-or-volume-group>|<volume-name>"
        mount_or_vg, name = urlparse.urlparse(uri).path.split('|')
        return ('qcow2:///' + mount_or_vg, name)

    @staticmethod
    def attach_internal(dbg, opq, vdi, vol_path, cb):
        protocol = 'Qdisk'

        log.debug("attach: doing qcow2 attach")
        # spawn an upstream qemu as a standalone backend
        qemu_be = qemudisk.create(dbg, vdi.uuid)
        log.debug("attach: created %s" % qemu_be)
        data_metadata_path = cb.get_data_metadata_path(opq, vdi.uuid)
        qemudisk.save_qemudisk_metadata(dbg,
                                        data_metadata_path,
                                        qemu_be)
        log.debug("attach: saved metadata with %s, %s" %
                  (cb.get_data_metadata_path(opq, vdi.uuid), qemu_be))

        params = 'nbd:unix:{}'.format(qemu_be.nbd_unix_sock)

        # Format is "<device>:<node-name>:<qmp-socket-path>"
        # This information is picked up by qemuback and passed via qmp
        # to the qemu process on hotplug
        qemu_params = '%s:%s:%s' % (
            vdi.uuid, qemudisk.LEAF_NODE_NAME, qemu_be.qmp_sock)
        # TODO extra_params = {'qemu_params': qemu_params}

        # TODO ideally we would return something like
        # extra_xenstore_params separately from params. For now we
        # rely on a hack in xenopsd that splits 'params' into these
        # two fields.

        params = "hack|%s|%s" % (params, qemu_params)
        return (protocol, params)

    @staticmethod
    def activate_internal(dbg, opq, vdi, img, cb):
        log.debug(
            "activate: doing qcow2 activate with img '%s'"
            % (img))
        vdi_meta_path = cb.get_data_metadata_path(opq, vdi.uuid)
        qemu_be = qemudisk.load_qemudisk_metadata(
            dbg, vdi_meta_path)
        qemu_be.open(dbg, vdi.uuid, img)
        qemudisk.save_qemudisk_metadata(dbg,
                                        vdi_meta_path,
                                        qemu_be)

    @staticmethod
    def deactivate_internal(dbg, opq, vdi, img, cb):
        """
        Do the qdisk specific deactivate
        """
        log.debug(
            "deactivate: doing qcow2 deactivate with img '%s'"
            % (img))
        qemu_be = qemudisk.load_qemudisk_metadata(
            dbg, cb.get_data_metadata_path(opq, vdi.uuid))
        qemu_be.close(dbg, vdi.uuid, img)
        metadata_path = cb.get_data_metadata_path(opq, vdi.uuid)
        qemudisk.save_qemudisk_metadata(dbg,
                                        metadata_path,
                                        qemu_be)

    @staticmethod
    def detach_internal(dbg, opq, vdi, cb):
        log.debug("detach: find and kill the qemu")
        vdi_meta_path = cb.get_data_metadata_path(opq, vdi.uuid)
        qemu_be = qemudisk.load_qemudisk_metadata(dbg, vdi_meta_path)
        qemu_be.quit(dbg, vdi.uuid)
