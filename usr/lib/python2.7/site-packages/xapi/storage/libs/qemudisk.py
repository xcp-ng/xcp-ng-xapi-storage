import os
import errno
import time
import subprocess
import xen.lowlevel.xs

# TODO: Get rid of 'image' module
# import image
from xapi.storage.libs import qmp
from xapi.storage.libs.util import var_run_prefix
from xapi.storage.libs.util import call
from xapi.storage import log
import cPickle

QEMU_PROC_METADATA_FILE = "meta.pickle"

QEMU_DP = "/usr/lib64/qemu-dp/bin/qemu-dp"
NBD_CLIENT = "/usr/sbin/nbd-client"

IMAGE_TYPES = frozenset(['qcow2'])
LEAF_NODE_NAME = 'qemu_node'
NEW_LEAF_NODE_NAME = 'new_qemu_node'


class Qemudisk(object):
    def __init__(self, pid, qmp_sock, key, f):
        self.pid = pid
        self.qmp_sock = qmp_sock
        self.key = key
        self.f = f
        self.nbd_unix_sock = var_run_prefix() + "/qemu-nbd.{}".format(key)

    def __repr__(self):
        return "Qemudisk(%d, %s, %s, %s)" % (self.pid,
                                             self.qmp_sock,
                                             self.key,
                                             self.f)

    def get_nbd_device_path(self, dbg, key):
        return "/dev/qemudisk/%s" % (key)

    def _qmp_connect(self, dbg):
        for i in range(1, 200):
            try:
                self.qmp = qmp.QEMUMonitorProtocol(self.qmp_sock)
                self.qmp.connect()
                break
            except:
                log.debug("%s: _qmp_connect has failed" % dbg)
                time.sleep(0.1)

    def _qmp_disconnect(self, dbg):
        self.qmp.close()
        self.qmp = None

    def _qmp_command(self, dbg, command, **args):
        log.debug("%s: sending QMP '%s' args %s" % (dbg, command, args))
        resp = self.qmp.command(command, **args)
        log.debug("%s: received QMP response '%s'" % (dbg, resp))
        return resp

    def open(self, dbg, key, f):
        # FIXME: this would not work for raw support
        # assert isinstance(f, image.Cow)
        log.debug("%s: opening image %s in qemu with sock %s" %
                  (dbg, f, self.qmp_sock))
        self.f = f.path
        self._qmp_connect(dbg)
        # FIXME: we can not hardcode qcow2 here
        # args = {"driver": "raw",
        args = {"driver": "qcow2",
                "cache": {'direct': True, 'no-flush': True},
                'discard': 'unmap',
                "file": {'driver': 'file', 'aio': 'native',
                         'filename': f.path},
                "node-name": LEAF_NODE_NAME}
        self._qmp_command(dbg, "blockdev-add", **args)

        # Start an NBD server exposing this blockdev
        self._qmp_command(dbg, "nbd-server-start",
                          addr={'type': 'unix',
                                'data': {'path': self.nbd_unix_sock}})
        self._qmp_command(dbg, "nbd-server-add",
                          device=LEAF_NODE_NAME, writable=True)
        self._qmp_disconnect(dbg)

    def close(self, dbg, key, f):
        # FIXME: this would not work for raw support
        # assert isinstance(f, image.Cow)
        log.debug("%s: closing image %s in qemu with sock %s" %
                  (dbg, f, self.qmp_sock))

        try:
            path = "{}/{}".format(var_run_prefix(), key)
            with open(path, 'r') as f:
                line = f.readline().strip()
            call(dbg, ["/usr/bin/xenstore-write", line, "5"])
            os.unlink(path)
        except:
            log.debug("%s: there was no xenstore setup" % dbg)

        # Stop the NBD server
        try:
            self._qmp_connect(dbg)
        except Exception as x:
            # TODO check this
            log.debug(
                "%s: got exception '%s' on qmp.connect; assuming qemu is dead"
                % (dbg, x))
            return

        self._qmp_command(dbg, "nbd-server-stop")

        # Remove the block device
        # (TODO not fully supported so says "Node <name> is in use")
        args = {"node-name": LEAF_NODE_NAME}
        for i in range(50):
            try:
                self._qmp_command(dbg, "blockdev-del", **args)
                break
            except Exception as x:
                if 'Cannot find node' in x.message:
                    break
                time.sleep(0.1)
                # TODO temporary hack
                log.debug(
                    "%s: suppressing genuine exception '%s' on blockdev-del" %
                    (dbg, x))
        self._qmp_disconnect(dbg)

    def quit(self, dbg, key):
        # ask the qemu process to shutdown
        try:
            self._qmp_connect(dbg)
            self._qmp_command(dbg, "quit")
            self._qmp_disconnect(dbg)
        except:
            pass

    def commit(self, dbg, node, parent):
        self._qmp_connect(dbg)
        args = {"job-id": "commit-{}".format(node),
                "device": LEAF_NODE_NAME,
                "top": node,
                "base": parent}
        self._qmp_command(dbg, 'block-commit', **args)
        for i in range(50):
            res = self._qmp_command(dbg, "query-block-jobs")
            if len(res) == 0:
                break
            time.sleep(0.1)
        self._qmp_disconnect(dbg)

    def relink(self, dbg, node, parent):
        self._qmp_connect(dbg)
        args = {"job-id": "commit-{}".format(node),
                "device": LEAF_NODE_NAME,
                "top": node,
                "base": parent,
                "backing-file": parent}
        self._qmp_command(dbg, 'relink-chain', **args)
        self._qmp_disconnect(dbg)

    def snap(self, dbg, new_path):
        self._qmp_connect(dbg)
        args = {"driver": "qcow2",
                "cache": {'direct': True, 'no-flush': True},
                'discard': 'unmap',
                "file": {'driver': 'file', 'aio': 'native',
                         'filename': new_path},
                "node-name": NEW_LEAF_NODE_NAME,
                "backing": ""}
        self._qmp_command(dbg, "blockdev-add", **args)
        args = {"node": LEAF_NODE_NAME,
                "overlay": NEW_LEAF_NODE_NAME}
        self._qmp_command(dbg, 'blockdev-snapshot', **args)
        self._qmp_disconnect(dbg)
        self.f = new_path


def find_qdisk_by_path(dbg, path):
    xs = xen.lowlevel.xs.xs()
    for frontend_domain_id in xs.ls('', '/local/domain/0/backend/qdisk'):
        for device_id in xs.ls('', '/local/domain/0/backend/qdisk/%s'
                               % (frontend_domain_id)):
            uri_param = xs.read(
                '', '/local/domain/0/backend/qdisk/%s/%s/params'
                % (frontend_domain_id, device_id))
            if uri_param == ("qcow2:" + path):
                qdisk = {}
                qdisk["frontend_domain_id"] = frontend_domain_id
                qdisk["device_id"] = device_id
                return qdisk
    return None


def create(dbg, key):
    qmp_sock = var_run_prefix() + "/qmp_sock.%s" % (key)
    log.debug("spawning qemu process with qmp socket at %s" % (qmp_sock))
    cmd = [QEMU_DP, qmp_sock]
    try:
        os.makedirs(var_run_prefix())
    except:
        pass
    f = open(var_run_prefix() + "/qemu_log.%s" % (key), 'w+')
    p = subprocess.Popen(cmd, stdout=f, stderr=f)
    log.debug("new qemu process has pid %d" % (p.pid))
    # TODO wait for the qmp socket to come up
    # TODO query qmp capabilities?
    return Qemudisk(p.pid, qmp_sock, key, None)


# TODO lots of code duplicated from tapdisk.py below here

def _metadata_dir(path):
    return os.path.join(var_run_prefix(), "nonpersistent",
                        "dp-qemu", os.path.realpath(path).lstrip('/'))


def save_qemudisk_metadata(dbg, path, tap):
    """ Record the qemudisk metadata for this VDI in host-local storage """
    dirname = _metadata_dir(path)
    try:
        os.makedirs(dirname, mode=0755)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    with open(dirname + "/" + QEMU_PROC_METADATA_FILE, "w") as fd:
        cPickle.dump(tap.__dict__, fd)


def load_qemudisk_metadata(dbg, path):
    """Recover the qemudisk metadata for this VDI from host-local
       storage."""
    dirname = _metadata_dir(path)
    log.debug("%s: load_qemudisk_metadata: trying '%s'" % (dbg, dirname))
    filename = dirname + "/" + QEMU_PROC_METADATA_FILE
    # No need to check for file existence;
    # if file not there, IOError is raised
    # if not(os.path.exists(filename)):
    #    raise Exception('volume doesn\'t exist')
    #    #raise xapi.storage.api.v5.volume.Volume_does_not_exist(dirname)
    with open(filename, "r") as fd:
        meta = cPickle.load(fd)
        qemu_be = Qemudisk(meta['pid'], meta['qmp_sock'],
                           meta['key'], meta['f'])

    return qemu_be
